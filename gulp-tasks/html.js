// JavaScript Document

// Scripts written by __gulp_init__author_name @ __gulp_init__author_company

module.exports = {
    html(GULP, PLUGINS, RAN_TASKS, ON_ERROR) {
        // read data from package.json
        const NAME            = PLUGINS.json.readFileSync("./package.json").name;
        const PWA_NAME        = PLUGINS.json.readFileSync("./package.json")["progressive-web-app"].name;
        const PWA_SHORT_NAME  = PLUGINS.json.readFileSync("./package.json")["progressive-web-app"].short_name;
        const PWA_THEME_COLOR = PLUGINS.json.readFileSync("./package.json")["progressive-web-app"].theme_color;
        const DESCRIPTION     = PLUGINS.json.readFileSync("./package.json").description;
        const VERSION         = PLUGINS.json.readFileSync("./package.json").version;
        const REPOSITORY      = PLUGINS.json.readFileSync("./package.json").repository;
        const LICENSE         = PLUGINS.json.readFileSync("./package.json").license;

        // copy binaries
        const COPY_BINARIES = (HTML_DIRECTORY, source = [global.settings.paths.src + "/**/*", "!" + global.settings.paths.src + "{/assets,/assets/**}"]) => {
            return GULP.src(source)
                // prevent breaking on error
                .pipe(PLUGINS.plumber({errorHandler: ON_ERROR}))
                // check if source is newer than destination
                .pipe(PLUGINS.gulpif(!PLUGINS.argv.dist, PLUGINS.newer(HTML_DIRECTORY)))
                // check if a file is a binary
                .pipe(PLUGINS.is_binary())
                // skip file if it's not a binary
                .pipe(PLUGINS.through.obj((file, enc, next) => {
                    if (!file.isBinary()) {
                        next();
                        return;
                    }

                    // go to next file
                    next(null, file);
                }))
                // output to compiled directory
                .pipe(GULP.dest(HTML_DIRECTORY));
        };

        // process HTML
        const PROCESS_HTML = (HTML_DIRECTORY, source = [global.settings.paths.src + "/**/*", "!" + global.settings.paths.src + "{/assets,/assets/**}"]) => {
            return GULP.src(source)
                // prevent breaking on error
                .pipe(PLUGINS.plumber({errorHandler: ON_ERROR}))
                // check if source is newer than destination
                .pipe(PLUGINS.gulpif(!PLUGINS.argv.dist, PLUGINS.newer(HTML_DIRECTORY)))
                // check if file is a binary
                .pipe(PLUGINS.is_binary())
                // skip file if it's a binary
                .pipe(PLUGINS.through.obj((file, enc, next) => {
                    if (file.isBinary()) {
                        next();
                        return;
                    }

                    // go to next file
                    next(null, file);
                }))
                // replace variables
                .pipe(PLUGINS.file_include({
                    prefix:   "@@",
                    basepath: "@file",
                    context: {
                        NAME,
                        PWA_NAME,
                        PWA_SHORT_NAME,
                        PWA_THEME_COLOR,
                        DESCRIPTION,
                        VERSION,
                        REPOSITORY,
                        LICENSE,
                    }
                }))
                // replace icon placeholders
                .pipe(PLUGINS.replace(/(?:<icon )(?=(?:.*?(?:use=(?:"|')(.*?)(?:"|')))?)(?=(?:[^>]+?(?:class=(?:"|')(.*?)(?:"|')))?)(?:.*?)(?: \/)?[^?](?:>)/g, "<i class='icon $2'><svg class='icon_svg' aria-hidden='true'><use xlink:href='#$1' /></svg></i>"))
                // minify
                .pipe(PLUGINS.gulpif(PLUGINS.argv.dist, PLUGINS.htmlmin({collapseWhitespace: true, ignoreCustomFragments: [ /<%[\s\S]*?%>/, /<\?[\s\S]*?(\?>|$)/ ], includeAutoGeneratedTags: false})))
                // output to compiled directory
                .pipe(GULP.dest(HTML_DIRECTORY));
        };

        // html task, copies binaries, converts includes & variables in HTML
        return new Promise ((resolve) => {
            // set HTML directory
            const HTML_DIRECTORY = PLUGINS.argv.dist ? global.settings.paths.dist : global.settings.paths.dev;

            // clean directory if --dist is passed
            if (PLUGINS.argv.dist) {
                PLUGINS.del([HTML_DIRECTORY + "/**/*", "!" + HTML_DIRECTORY + "{/assets,/assets/**}"]);
            }

            // process all non-asset files
            const BINARIES = COPY_BINARIES(HTML_DIRECTORY, [global.settings.paths.src + "/**/*", "!" + global.settings.paths.src + "{/assets,/assets/**}"]);
            const HTML     = PROCESS_HTML(HTML_DIRECTORY, [global.settings.paths.src + "/**/*", "!" + global.settings.paths.src + "{/assets,/assets/**}"]);

            // merge both steams back in to one
            return PLUGINS.merge(BINARIES, HTML)
                // prevent breaking on error
                .pipe(PLUGINS.plumber({errorHandler: ON_ERROR}))
                // reload files
                .pipe(PLUGINS.browser_sync.reload({stream: true}))
                // notify that task is complete, if not part of default or watch
                .pipe(PLUGINS.gulpif(GULP.seq.indexOf("html") > GULP.seq.indexOf("default"), PLUGINS.notify({title: "Success!", message: "HTML task complete!", onLast: true})))
                // push task to RAN_TASKS array
                .on("data", () => {
                    if (RAN_TASKS.indexOf("html") < 0) {
                        RAN_TASKS.push("html");
                    }
                })
                .on("end", () => {
                    return resolve();
                });
        });
    }
};
